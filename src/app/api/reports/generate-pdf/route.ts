import { NextRequest, NextResponse } from 'next/server';
import { Report } from 'fluentreports';
import fs from 'fs';
import path from 'path';
import { createAdminClient } from '@/lib/appwrite';
import { appwriteConfig } from '@/lib/appwrite/config';

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { reportId, department, metrics, userRole, userName, aiContent } =
      body;

    if (
      !reportId ||
      !department ||
      !metrics ||
      !userRole ||
      !userName ||
      !aiContent
    ) {
      return NextResponse.json(
        { error: 'Missing required fields for PDF generation' },
        { status: 400 }
      );
    }

    // Create a new Fluent Report
    const report = new Report({
      pageSize: 'A4',
      pageOrientation: 'portrait',
      pageMargins: [40, 60, 40, 60],
      font: 'Helvetica',
      fontSize: 10,
      color: '#000000',
      border: { all: { color: '#000000', style: 'solid', width: 1 } },
      printBackground: true,
    });

    // Define report content
    const reportTitle = `${
      department === 'all' ? 'All Departments' : department
    } Analytics Report`;
    const reportDate = new Date().toLocaleDateString();

    // Add header
    report.printHeader((doc: any) => {
      doc.setFontSize(18);
      doc.setFont('helvetica', 'bold');
      doc.text(reportTitle, 40, 30);

      doc.setFontSize(10);
      doc.setFont('helvetica', 'normal');
      doc.text(`Generated by: ${userName} (${userRole})`, 40, 45);
      doc.text(`Generated on: ${reportDate}`, 40, 55);

      // Add a line separator
      doc.setDrawColor(0, 123, 255);
      doc.setLineWidth(2);
      doc.line(40, 60, 550, 60);
    });

    // Add footer
    report.printFooter((doc: any) => {
      doc.setFontSize(8);
      doc.setFont('helvetica', 'normal');
      doc.text('CAALM Solutions - Analytics Report', 40, 800);
      doc.text(
        `Page ${doc.internal.getCurrentPageInfo().pageNumber}`,
        500,
        800
      );
    });

    // Add main content
    report.printDetail((doc: any, data: any) => {
      let yPosition = 80;

      // Report metadata section
      doc.setFontSize(12);
      doc.setFont('helvetica', 'bold');
      doc.text('Report Overview', 40, yPosition);
      yPosition += 20;

      doc.setFontSize(10);
      doc.setFont('helvetica', 'normal');
      doc.text(
        `Department: ${department === 'all' ? 'All Departments' : department}`,
        40,
        yPosition
      );
      yPosition += 15;
      doc.text(`Generated by: ${userName} (${userRole})`, 40, yPosition);
      yPosition += 15;
      doc.text(`Generated on: ${reportDate}`, 40, yPosition);
      yPosition += 25;

      // Metrics section
      doc.setFontSize(12);
      doc.setFont('helvetica', 'bold');
      doc.text('Key Metrics', 40, yPosition);
      yPosition += 20;

      doc.setFontSize(10);
      doc.setFont('helvetica', 'normal');

      // Create a table for metrics
      const metricsData = [
        ['Metric', 'Value'],
        ['Total Contracts', metrics.contracts.toString()],
        ['Active Users', metrics.users.toString()],
        ['Scheduled Events', metrics.events.toString()],
        ['Stored Files', metrics.files.toString()],
      ];

      // Draw metrics table
      const tableTop = yPosition;
      const tableLeft = 40;
      const colWidths = [150, 100];
      const rowHeight = 20;

      // Draw table headers
      doc.setFont('helvetica', 'bold');
      doc.setFillColor(240, 240, 240);
      doc.rect(
        tableLeft,
        tableTop,
        colWidths[0] + colWidths[1],
        rowHeight,
        'F'
      );

      doc.text(metricsData[0][0], tableLeft + 5, tableTop + 12);
      doc.text(metricsData[0][1], tableLeft + colWidths[0] + 5, tableTop + 12);

      // Draw table rows
      doc.setFont('helvetica', 'normal');
      for (let i = 1; i < metricsData.length; i++) {
        const rowY = tableTop + i * rowHeight;
        doc.text(metricsData[i][0], tableLeft + 5, rowY + 12);
        doc.text(metricsData[i][1], tableLeft + colWidths[0] + 5, rowY + 12);

        // Draw row border
        doc.setDrawColor(200, 200, 200);
        doc.line(
          tableLeft,
          rowY + rowHeight,
          tableLeft + colWidths[0] + colWidths[1],
          rowY + rowHeight
        );
      }

      yPosition = tableTop + metricsData.length * rowHeight + 30;

      // AI Analysis section
      doc.setFontSize(12);
      doc.setFont('helvetica', 'bold');
      doc.text('AI Analysis', 40, yPosition);
      yPosition += 20;

      doc.setFontSize(10);
      doc.setFont('helvetica', 'normal');

      // Clean AI content (remove HTML tags)
      const cleanAIContent = aiContent
        .replace(/<[^>]*>/g, '')
        .replace(/&nbsp;/g, ' ');

      // Split content into lines that fit the page width
      const maxWidth = 470; // Page width minus margins
      const lines = doc.splitTextToSize(cleanAIContent, maxWidth);

      // Add AI content with proper line breaks
      for (let i = 0; i < lines.length; i++) {
        if (yPosition > 750) {
          // Check if we need a new page
          doc.addPage();
          yPosition = 80;
        }
        doc.text(lines[i], 40, yPosition);
        yPosition += 15;
      }
    });

    // Generate PDF buffer
    const pdfBuffer = await new Promise<Buffer>((resolve, reject) => {
      const chunks: Buffer[] = [];

      report.render((err: any, stream: any) => {
        if (err) {
          reject(err);
          return;
        }

        stream.on('data', (chunk: Buffer) => {
          chunks.push(chunk);
        });

        stream.on('end', () => {
          resolve(Buffer.concat(chunks));
        });

        stream.on('error', (err: any) => {
          reject(err);
        });
      });
    });

    // Store PDF file in the public directory
    const pdfDir = path.join(process.cwd(), 'public', 'reports');
    if (!fs.existsSync(pdfDir)) {
      fs.mkdirSync(pdfDir, { recursive: true });
    }

    const pdfFileName = `report_${reportId}.pdf`;
    const pdfPath = path.join(pdfDir, pdfFileName);

    fs.writeFileSync(pdfPath, pdfBuffer);

    // Update the report document with PDF file path
    const adminClient = await createAdminClient();
    await adminClient.databases.updateDocument(
      appwriteConfig.databaseId,
      appwriteConfig.reportsCollectionId,
      reportId,
      {
        pdfFilePath: `/reports/${pdfFileName}`,
        pdfGenerated: true,
      }
    );

    return NextResponse.json({
      success: true,
      pdfPath: `/reports/${pdfFileName}`,
      message: 'PDF generated successfully',
    });
  } catch (error) {
    console.error('Error generating PDF:', error);
    return NextResponse.json(
      {
        error: 'Failed to generate PDF',
        details: error instanceof Error ? error.message : 'Unknown error',
      },
      { status: 500 }
    );
  }
}
